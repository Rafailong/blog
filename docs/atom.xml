<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rafailong.github.io/blog/</id>
    <title>ravila' blog Blog</title>
    <updated>2022-01-26T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rafailong.github.io/blog/"/>
    <subtitle>ravila' blog Blog</subtitle>
    <icon>https://rafailong.github.io/blog/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[is the number a palindrome?]]></title>
        <id>number-is-palindrome</id>
        <link href="https://rafailong.github.io/blog/number-is-palindrome"/>
        <updated>2022-01-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[description]]></summary>
        <content type="html"><![CDATA[<h2>description</h2><p>Given an integer <code>x</code>, return <code>true</code> if <code>x</code> is palindrome integer.
An integer is a palindrome when it reads the same backward as forward.
For example, <code>121</code> is a palindrome while <code>123</code> is not.</p><h3>constraints</h3><ul><li><code>x &gt;= 0</code></li><li>usage of strings is prohibited</li></ul><h2>solution</h2><p>first idea is to decompose the given number in 3 parts:</p><pre><code>x = 123321
first  = 1
last   = 1
others = 2332
</code></pre><p>with the number decoposition it would be possible to decompose the number till either:</p><ol><li><code>first != last</code></li><li>or, it is not possible to decompose the number i.e. number of one digit <code>1</code></li></ol><p>so, let&#x27;s try to implement a function to decompose a nuber:</p><pre><code class="language-scala">def isOneDigit(n: Int): Boolean = n &gt;= 0 &amp;&amp; n &lt; 10

def deconstruct(number: Int): (Int, Option[Int], Int) = {

  if (isOneDigit(number)) (number, None, number)
  else {

    val n = {
      val a = Math.log10(number).intValue()
      Math.pow(10, a).intValue()
    }

    val firstDigit = number / n
    val lastDigit = number % 10
    val left = {
      if (isOneDigit(number / 10)) None
      else Some((number % n) / 10)
    }

    (firstDigit, left, lastDigit)
  }
}
</code></pre><p>as you case <code>deconstruct</code> returns a three-tuple with an <code>Option</code> in the middle.
let&#x27;s see how <code>deconstruct</code> behaves:</p><pre><code class="language-scala">deconstruct(123)
// res0: (Int, Option[Int], Int) = (1, Some(value = 2), 3)
deconstruct(1)
// res1: (Int, Option[Int], Int) = (1, None, 1)
deconstruct(11)
// res2: (Int, Option[Int], Int) = (1, None, 1)
</code></pre><p>okay... it seems there are couple special cases here:</p><ol><li>when we pass a 1-digit number: <code>first</code> and <code>last</code> will be <em>that</em> and <code>others</code> will be a <code>None</code> </li><li>and, when we pass a 2-digits number: <code>other</code> will be <code>None</code> too</li></ol><p>so, it seems we kind of have a base case for a recursive function that will find out
if a number is a palindrome or not:</p><pre><code class="language-scala">def isPalindrome(number: Int): Boolean = {
  @tailrec
  def recur(number: Int, acc: Boolean): Boolean = {
    val (h, ns, t) = deconstruct(number)
    val bool       = h == t &amp;&amp; acc
    if (bool) {
      ns match {
        case Some(value) =&gt; recur(value, bool)
        case None        =&gt; bool
      }
    } else false
  }

  recur(number, true)
}

isPalindrome(1203021)
// res3: Boolean = false
isPalindrome(123421)
// res4: Boolean = false
isPalindrome(123321)
// res5: Boolean = true
isPalindrome(10001)
// res6: Boolean = true
isPalindrome(1000)
// res7: Boolean = false
isPalindrome(8)
// res8: Boolean = true
isPalindrome(0)
// res9: Boolean = true
</code></pre><p>welp... obviously something is not working as expects ðŸ˜“
our <code>deconstruct</code> functions seem to be the suspected here.
so let&#x27;s <em>debug</em> it:</p><pre><code class="language-scala">deconstruct(1203021) == (1, Some(20302), 1)
// res10: Boolean = true
deconstruct(20302)
// res11: (Int, Option[Int], Int) = (2, Some(value = 30), 2)
</code></pre><p>ðŸ¤¡ <code>deconstruct</code> has no respect for the leading zeros which is OK because <code>30 = 030</code> and we are working with <code>Int</code>s</p><p>time to try different approach. what bout an accumulative approach?</p><pre><code class="language-scala">case class Acc private (org: List[Int], reversed: List[Int]) { self =&gt;
  def add(digit: Int): Acc = Acc(
    org      = self.org :+ digit,
    reversed = digit +: self.reversed
  )
}
object Acc {
  def empty: Acc = Acc(List.empty, List.empty)
}
</code></pre><p><code>Acc</code> is our accumulative structure. it does maintian 2 lists
and every time we want to <code>add</code> a number to it:</p><ol><li>it will append the digit to one list <code>org</code></li><li>and, it will preppend the same digit to the other list <code>reversed</code></li></ol><p>time to implement our function to check if a number is palindrome or not
using <code>Acc</code>:</p><pre><code class="language-scala">def lastDigit(n: Int): Int = n % 10

def isPalindromeAcc(x: Int): Boolean =
  if (isOneDigit(x)) true
  else {

    @tailrec
    def go(acc: Acc, n: Int): Acc =
      if (n &gt; 0) go(((acc.add _) compose (lastDigit _))(n), n / 10)
      else acc

    val Acc(org, reversed) = go(Acc.empty, x)
    org sameElements reversed
  }
</code></pre><p>the function <code>isPalindromAcc</code>:</p><ul><li>check if <code>x</code> is a number of one digit (short-circuit)</li><li>&quot;deconstruct&quot; <code>x</code> from right to left and <code>add</code>-em to an <code>Acc</code></li><li>and last step, it compares the list from <code>Acc</code> using <code>sameElements</code>
which checks that both list contains the same elements at the same order</li></ul><p>let&#x27;s give it a try:</p><pre><code class="language-scala">isPalindromeAcc(1203021)
// res12: Boolean = true
isPalindromeAcc(123421)
// res13: Boolean = false
isPalindromeAcc(10001)
// res14: Boolean = true
isPalindromeAcc(1000)
// res15: Boolean = false
isPalindromeAcc(8)
// res16: Boolean = true
isPalindromeAcc(0)
// res17: Boolean = true
</code></pre><p>this looks much better! ðŸ¥³ things to note:</p><ul><li><code>isPalindrom</code> works perfectly for numbers without zeros in the middle and it is more efficient that <code>isPalindromAcc</code> in both time and space</li><li><code>isPalindromAcc</code> work great with any <code>x &gt;= 0</code> but it is memory heavy</li></ul>]]></content>
        <author>
            <name>Rafael Avila</name>
            <uri>https://github.com/Rafailong</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[sum triangle from array]]></title>
        <id>sum-triangle-from-array</id>
        <link href="https://rafailong.github.io/blog/sum-triangle-from-array"/>
        <updated>2022-01-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[another week, another code challenge]]></summary>
        <content type="html"><![CDATA[<p>another week, another code challenge</p><h2>description</h2><p>given an array of integers, print a sum triangle from it such that
the first level has all array elements.
from then, at each level number of elements is one less than the previous level
and elements at the level is be the <strong>sum</strong> of consecutive two elements in the previous level. </p><h3>example</h3><pre><code class="language-scala">def sumTriangle(number: List[Int]): List[List[Int]] = ???

val input = List(1, 2, 3, 4, 5)

show(
  sumTriangle(input)
)
// stdout output
// List(
//   List(48),
//   List(20, 28), 
//   List(8, 12, 16), 
//   List(3, 5, 7, 9), 
//   List(1, 2, 3, 4, 5)
// )
</code></pre><h2>solution</h2><p>first, we need to find a way to sum the elements of a list in pairs,
something that does like:</p><pre><code class="language-haskell">[1, 2, 3, 4, 5] -&gt; [1 + 2, 2 + 3, 3 + 4, 4 + 5] = [3, 5, 7, 9]
</code></pre><p>ðŸ¤” intresting enough, this looks like we need to <code>zip</code> one element with its successor.</p><pre><code class="language-scala">def sum(ns: List[Int]): List[Int] =
  ns.zip(ns.tail).map { case (a, b) =&gt; a + b }

sum(List(1, 2, 3, 4, 5))
// res0: List[Int] = List(3, 5, 7, 9)
</code></pre><p>nice! this seems to work correctly. now that we can produce a level of
our trigle from a base level next step is to produce the whole triangle
from our input level (base level).</p><p>but first, let&#x27;s get a bit piky and define a type alias for our triangle</p><pre><code class="language-scala">type Triangle = List[List[Int]]

object Triangle {
  def apply(ns: List[Int]): Triangle = ns :: Nil
}
</code></pre><p>now we can implement our <em>main</em> function:</p><pre><code class="language-scala">def sumTriangle(numbers: List[Int]): Triangle = {

  @tailrec
  def go(ns: List[Int], triangle: Triangle): Triangle =
    ns match {
      case _ :: _ =&gt;
        val level = sum(ns)
        go(level, level :: triangle)
      case Nil =&gt; triangle
    }

  go(numbers, Triangle(numbers))
}
</code></pre><p>as you may notice, this implementation is tail recursive (proved by the compiler)
and it builds a triangle from bottom to top.
let&#x27;s give it a try!</p><pre><code class="language-scala">val triangle = sumTriangle(
  List(1, 2, 3, 4, 5)
)
// triangle: Triangle = List(
//   List(),
//   List(48),
//   List(20, 28),
//   List(8, 12, 16),
//   List(3, 5, 7, 9),
//   List(1, 2, 3, 4, 5)
// )
</code></pre><p>as an extra let&#x27;s try to pretty print our triangle</p><pre><code class="language-scala">def show(triangle: Triangle): String =
  triangle.foldRight(&quot;&quot;) { case (ns, str) =&gt;
    s&quot;${ns.mkString(&quot;,&quot;)}&quot; ++ System.lineSeparator() ++ str
  }

show(triangle)
// res1: String = &quot;&quot;&quot;
// 48
// 20,28
// 8,12,16
// 3,5,7,9
// 1,2,3,4,5
// &quot;&quot;&quot;
</code></pre><blockquote><p>PS. worth to mention that this blog post is a markdown file processed with the awesome <a href="https://scalameta.org/mdoc/">mdoc</a> ðŸ¤“</p></blockquote>]]></content>
        <author>
            <name>Rafael Avila</name>
            <uri>https://github.com/Rafailong</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[add two number]]></title>
        <id>add-two-numbers</id>
        <link href="https://rafailong.github.io/blog/add-two-numbers"/>
        <updated>2022-01-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[time to solve another coding challenge.]]></summary>
        <content type="html"><![CDATA[<p>time to solve another coding challenge.</p><h2>description</h2><p>You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order, and each of their nodes contains a single digit.
Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero,
except the number 0 itself.</p><h3>example</h3><pre><code class="language-haskell">l1 = [2, 4, 3] -- 342
l2 = [5, 6, 4] -- 465

addTwoNumbers l1 l2 == [7, 0, 8] -- 807 == 342 + 465
</code></pre><h3>constraints</h3><ol><li>the number of nodes in each linked list is in the range <code>[1, 100]</code></li><li><code>0 &lt;= ListNode.x &lt;= 9</code></li><li>it is guaranteed that the list represents a number that does not have leading zeros</li></ol><h3>linked list representations</h3><pre><code class="language-scala">// yes. this is no idiomatic scala. but for now, bear with me please!

case class ListNode(_x: Int = 0, _next: ListNode = null) {
  var next: ListNode = _next
  var x: Int = _x
}
</code></pre><h2>solution</h2><p>first, we need to define a function signature:</p><pre><code class="language-scala">def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = ???
</code></pre><p>then, let&#x27;s create input for our function.</p><pre><code class="language-scala">val n1 = new ListNode(2, new ListNode(4, new ListNode(3)))
val n2 = new ListNode(5, new ListNode(6, new ListNode(4)))
</code></pre><p>what comes to my mind is a recursive solution so we do as follow</p><pre><code class="language-scala">(2 + 5) == 7
(4 + 6) == 0 // 10 - we need to presereve the most-left digit (0) only and carry the other one (1) to the next operation
(3 + 4) == 7 + 1 == 8
</code></pre><p>first thing first. we need a way to work with a number <code>x</code> given that <code>x = number_of_list_1 + number_of_list_2</code>
and <code>x &gt;= 10</code></p><pre><code class="language-scala">// terrible name :(
def helper(n: Int): (Int, Int) =
  if (n &gt;= 10) (1, n % 10)
  else (0, n)
</code></pre><p>time to code our recursive helper functions</p><pre><code class="language-scala">/**
* @param as list 1
* @param bs list 2
* @param acc our seed/accumulator list
* @param r the digit to carry for the next operation
*          if the sum of two numbers is 10 then r = 1
*          for the next iteration 
*/
@tailrec
final def loop(as: ListNode, bs: ListNode, acc: ListNode, r: Int): ListNode = {
  (as, bs) match {
    // base case, when both lists are &quot;empty&quot;
    // BUT we have an r to include as last digit (not leading zero)
    case (null, null) if r &gt; 0 =&gt; new ListNode(r, acc)

    // base case, when both lists are &quot;empty&quot; but without r
    case (null, null)          =&gt; acc

    // following two cases are similar and handle
    // the scenario where one of the 2 lists have elements
    // but the other list is empty
    case (_, null) =&gt;
      val (nr, a) = helper(as.x + r)
      loop(
        as.next,
        bs = null,
        acc = new ListNode(a, acc),
        nr
      )
    case (null, _) =&gt;
      val (nr, b) = helper(bs.x + r)
      loop(
        as = null,
        bs.next,
        acc = new ListNode(b, acc),
        nr
      )

    // when both lists have elements
    case (_, _) =&gt;
      val a = as.x
      val b = bs.x
      val (nr, c) = helper(a + b + r)
      loop(
        as.next,
        bs.next,
        acc = new ListNode(c, acc),
        nr
      )
  }
}
</code></pre><p>it&#x27;s time to implement our &quot;main&quot; function</p><pre><code class="language-scala">def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
  // this is safe given the constraints above
  val a = l1.x
  val b = l2.x
  val (r, c) = helper(a + b)
  loop(
    l1.next,
    l2.next,
    acc = new ListNode(c),
    r
  )
}
</code></pre><p>time to give it a try to our solution:</p><pre><code class="language-scala">val listNode = addTwoNumbers(n1, n2)
// listNode: ListNode = ListNode(
//   _x = 8,
//   _next = ListNode(_x = 0, _next = ListNode(_x = 7, _next = null))
// )
</code></pre><p>hmm? maybe we can define a utility function to pretty print our list</p><pre><code class="language-scala">@tailrec
private def toList(ln: ListNode, acc: List[Int]): List[Int] =
  if (ln == null) acc
  else toList(ln.next, acc :+ ln.x)

def show(listNode: ListNode): String =
  toList(listNode, List.empty).mkString(&quot; -&gt; &quot;)

show(listNode)
// res0: String = &quot;8 -&gt; 0 -&gt; 7&quot;
</code></pre><p>once again <em>hmm?</em> our resulting list is not in good order, rigth?
why don&#x27;t we reverse it?</p><pre><code class="language-scala">def reverse(listNode: ListNode): ListNode = {

  @tailrec
  def loop(ln: ListNode, acc: ListNode): ListNode =
    if (ln == null) acc
    else loop(ln.next, new ListNode(ln.x, acc))

  loop(listNode.next, new ListNode(listNode.x))
}

show(
  reverse(listNode)
)
// res1: String = &quot;7 -&gt; 0 -&gt; 8&quot;
</code></pre><p>now that look better!</p><pre><code class="language-scala">def addTwoNumbersImproved(l1: ListNode, l2: ListNode): ListNode = {
  // this is safe given the constraints above
  val a = l1.x
  val b = l2.x
  val (r, c) = helper(a + b)
  reverse(
    loop(
      l1.next,
      l2.next,
      acc = new ListNode(c),
      r
    )
  )
}
</code></pre><p>but... that was a pretty simplistic way to test our solution, don&#x27;t you think?</p><p>we can do better with a great library:
<a href="https://scalacheck.org/index.html">scalacheck</a></p><p>let&#x27;s start importing what we need from scalacheck</p><pre><code class="language-scala">import org.scalacheck._
import org.scalacheck.Prop._
</code></pre><p>scalacheck work require us to define <code>Prop</code>s. our <code>Prop</code> will look
something like:</p><pre><code class="language-scala">val myProp = forAll { (input: (ListNode, ListNode, Int)) =&gt; ??? }
</code></pre><p>now it is time to define <code>Gen</code>s and <code>Arbitrary</code> required for our <code>Prop</code>
first, a <code>Gen[ListNode]</code></p><pre><code class="language-scala">//generates pair like:
// (
//   10,
//   ListNode(0, ListNode(1))
// )
val listNodeGen: Gen[(Int, ListNode)] = for {
  size &lt;- Gen.chooseNum(1, 8) // our lists will have up to 8 nodes
  head &lt;- Gen.chooseNum(1, 9) // we do this hold constraint no. 3
  tail &lt;- Gen.listOfN(size - 1, Gen.chooseNum(0, 9)) // trailing digits can be 0-9
  _list = head :: tail
  n = _list.mkString.toInt
  listNode = tail.reverse.foldRight(new ListNode(head)) { (i, ln) =&gt;
    new ListNode(i, ln)
  }
} yield (n, listNode)
</code></pre><p>now we need to define an <code>Arbitrary</code> for out <code>(ListNode, ListNode, Int)</code> type</p><pre><code class="language-scala">type Input = (ListNode, ListNode, Int)

// generates tuples like:
// (
//   ListNode(1),
//   ListNode(0, ListNode(1)),
//   11
// )
val inputGen: Gen[Input] =
  for {
    (n1, l1) &lt;- listNodeGen
    (n2, l2) &lt;- listNodeGen
  } yield (l1, l2, n1 + n2)

implicit val arb: Arbitrary[Input] = Arbitrary(inputGen)
</code></pre><p>we have all we need to define our <code>Prop</code></p><pre><code class="language-scala">val prop = forAll { (input: Input) =&gt;

  // unapplying our input to avoid `._1` syntax
  val (l1, l2, n) = input

  // applying our solution
  val result = addTwoNumbersImproved(l1, l2)

  // we need to do this in order to prove our solution
  val nn = {
    val reversed = reverse(result)
    // ListNode to immutable.List to Int
    toList(reversed, List.empty).mkString.toInt
  }

  n == nn
}
// prop: Prop = Prop

prop.check()
// + OK, passed 100 tests.
</code></pre><p>now with &quot;random&quot; inputs to our solution and 100 test
we can be somehow sure that it works! yay!</p>]]></content>
        <author>
            <name>Rafael Avila</name>
            <uri>https://github.com/Rafailong</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[sorted squared array]]></title>
        <id>sorted-squared-array</id>
        <link href="https://rafailong.github.io/blog/sorted-squared-array"/>
        <updated>2022-01-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[this time we will try to (satisfactory) solve a coding challenge.]]></summary>
        <author>
            <name>Rafael Avila</name>
            <uri>https://github.com/Rafailong</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[haskell dollar-sign operator]]></title>
        <id>dollar-sign-operator</id>
        <link href="https://rafailong.github.io/blog/dollar-sign-operator"/>
        <updated>2021-12-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The ($) operator is a convenience for when you want to express]]></summary>
        <content type="html"><![CDATA[<p>The <code>($)</code> operator is a convenience for when you want to express
something with less pairs of parenths.</p><p>Type of <code>($)</code> is:</p><pre><code class="language-haskell">($) :: (a -&gt; b) -&gt; a -&gt; b -- Defined in â€˜GHC.Baseâ€™
infixr 0 $
</code></pre><p>Which means that:</p><ol><li>it is a infix operator</li><li>it associates to the right</li><li>and, it has the lowest possibile precedence</li></ol><p>Usage example:</p><pre><code class="language-haskell">_ =(2^) (2 + 2) -- 16
</code></pre><p>Above code we need all the parenths because we want to first evaluate
<code>(2 + 2)</code>. If we remove the parenths the result is different:</p><pre><code class="language-haskell">_ = (2^) 2 + 2 -- 6
</code></pre><p>Here is where <code>($)</code> comes handy:</p><pre><code class="language-haskell">_ = (2^) $ 2 + 2 -- 16
</code></pre><p>This happens because of how <code>($)</code> associates.
So, first <code>(2 + 2)</code> is evaluted and its results is used in <code>(2^)</code>.</p>]]></content>
        <author>
            <name>Rafael Avila</name>
            <uri>https://github.com/Rafailong</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>welcome</id>
        <link href="https://rafailong.github.io/blog/welcome"/>
        <updated>2021-12-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Hi there and welcome to my blog!]]></summary>
        <content type="html"><![CDATA[<p>Hi there and welcome to my blog!</p><p>At a glance you will find content about things I like,
things I dislike, and things I might be learning/interested on.</p><p>So, that is all for now. Have a good one!</p>]]></content>
        <author>
            <name>Rafael Avila</name>
            <uri>https://github.com/Rafailong</uri>
        </author>
    </entry>
</feed>