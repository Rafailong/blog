"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9843],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(o,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(f,l(l({ref:t},u),{},{components:n})):a.createElement(f,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9886:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],s={slug:"balanced-brackets",title:"balanced brackets",authors:["ravila"],tags:["scala","interview"]},o=void 0,c={permalink:"/blog/balanced-brackets",editUrl:"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-05-02-balanced_parents.md",source:"@site/blog/2022-05-02-balanced_parents.md",title:"balanced brackets",description:"description",date:"2022-05-02T00:00:00.000Z",formattedDate:"May 2, 2022",tags:[{label:"scala",permalink:"/blog/tags/scala"},{label:"interview",permalink:"/blog/tags/interview"}],readingTime:2.14,truncated:!0,authors:[{name:"Rafael Avila",url:"https://github.com/Rafailong",imageURL:"https://github.com/Rafailong.png",key:"ravila"}],frontMatter:{slug:"balanced-brackets",title:"balanced brackets",authors:["ravila"],tags:["scala","interview"]},nextItem:{title:"find available languages",permalink:"/blog/available-languages"}},u={authorsImageUrls:[void 0]},p=[{value:"description",id:"description",level:2},{value:"solution",id:"solution",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"description"},"description"),(0,i.kt)("p",null,"this ",(0,i.kt)("em",{parentName:"p"},"problem")," is a classic.\ni got this one from an interview."),(0,i.kt)("p",null,"you\u2019re given the string as input consisting solely of ",(0,i.kt)("inlineCode",{parentName:"p"},"("),", ",(0,i.kt)("inlineCode",{parentName:"p"},")"),",\nand any alpha lower case chars ",(0,i.kt)("inlineCode",{parentName:"p"},"a-z"),".\ndetermine whether the parentheses are balanced."),(0,i.kt)("h2",{id:"solution"},"solution"),(0,i.kt)("p",null,"there are multiple solution to this challenge, but we will try to use scala feats."),(0,i.kt)("p",null,"first, we define out test data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// test data\nval testData = List(\n  "()",\n  "(()",\n  "(())",\n  ")(",\n  ")()",\n  "(((this(is)(my(test)(string(and)I)want)to)know((if)it)is)balanced)"\n)\n')),(0,i.kt)("p",null,"this solution levarege:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"scala's ",(0,i.kt)("inlineCode",{parentName:"li"},"tailrec")," optimization"),(0,i.kt)("li",{parentName:"ul"},"scala's ",(0,i.kt)("inlineCode",{parentName:"li"},"immutable.List")," as a stack (last-in first-out)"),(0,i.kt)("li",{parentName:"ul"},"and, some kind of short-circuiting i.e. ",(0,i.kt)("inlineCode",{parentName:"li"},'str = ")("'))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.annotation.tailrec\n\ndef isBalanced(str: String): Boolean = {\n  @tailrec\n  def validate(cs: List[Char], queue: List[Char]): Boolean = {\n    cs match {\n      case Nil         => queue.isEmpty\n      case \'(\' :: next => validate(next, \'(\' +: queue)\n      case \')\' :: next =>\n        if (queue.headOption.contains(\'(\') && queue.nonEmpty) validate(next, queue.tail)\n        else false\n      case _ :: next => validate(next, queue)\n    }\n  }\n\n  validate(str.toList, List.empty)\n}\n\ntestData.map { str =>\n  s"""is "$str" balanced? = ${isBalanced(str)}"""\n}\n// res0: List[String] = List(\n//   "is \\"()\\" balanced? = true",\n//   "is \\"(()\\" balanced? = false",\n//   "is \\"(())\\" balanced? = true",\n//   "is \\")(\\" balanced? = false",\n//   "is \\")()\\" balanced? = false",\n//   "is \\"(((this(is)(my(test)(string(and)I)want)to)know((if)it)is)balanced)\\" balanced? = true"\n// )\n')),(0,i.kt)("p",null,"this looks nice and dandy but, let's handle more types of brackets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val testData2 = List(\n  "(a)[b]{c}",\n  "([{}])",\n  "([{]})",\n  "( ([{}]) {} [] )"\n)\n')),(0,i.kt)("p",null,"we should be able to just improve our previous solution\nand preserve the 3 scala' feats listed above"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val open  = Set('(','[','{')\nval close = Set(')',']','}')\n\ndef isBalanced2(str: String): Boolean = {\n  @tailrec\n  def validate(cs: List[Char], queue: List[Char]): Boolean = {\n    cs match {\n      case Nil => queue.isEmpty\n      case h :: next if open.contains(h) => validate(next, h +: queue)\n      case h :: next if close.contains(h) =>\n\n        if queue.isEmpty then false\n        else\n          queue.headOption match {\n            case Some(o) =>\n              (o, h) match {\n                case ('(', ')') => validate(next, queue.tail)\n                case ('[', ']') => validate(next, queue.tail)\n                case ('{', '}') => validate(next, queue.tail)\n                case (_, _) => false\n              }\n            case None => false\n          }\n\n      case _ :: next => validate(next, queue)\n    }\n  }\n\n  validate(str.toList, List.empty)\n}\n")),(0,i.kt)("p",null,"okie dokie, ",(0,i.kt)("inlineCode",{parentName:"p"},"isBalanced2")," preserves the 3 feats listed above.\nlet's give it a shot:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'testData2.map { str =>\n  s"""is "$str" balanced? = ${isBalanced2(str)}"""\n}\n// res1: List[String] = List(\n//   "is \\"(a)[b]{c}\\" balanced? = true",\n//   "is \\"([{}])\\" balanced? = true",\n//   "is \\"([{]})\\" balanced? = false",\n//   "is \\"( ([{}]) {} [] )\\" balanced? = true"\n// )\n')))}m.isMDXComponent=!0}}]);