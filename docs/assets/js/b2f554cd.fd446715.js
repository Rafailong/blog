"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[477],{10:function(n){n.exports=JSON.parse('{"blogPosts":[{"id":"non-constructible-change","metadata":{"permalink":"/blog/non-constructible-change","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-04-22-non-constructible-change.md","source":"@site/blog/2022-04-22-non-constructible-change.md","title":"non-constructible change","description":"description","date":"2022-04-22T00:00:00.000Z","formattedDate":"April 22, 2022","tags":[{"label":"scala","permalink":"/blog/tags/scala"},{"label":"algo","permalink":"/blog/tags/algo"}],"readingTime":3.765,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"non-constructible-change","title":"non-constructible change","authors":["ravila"],"tags":["scala","algo"]},"nextItem":{"title":"roman number to decimal number","permalink":"/blog/roman-to-decimal"}},"content":"## description\\n\\n\\nGiven an array of positive integers representing the values of coins in your\\npossession, write a function that returns the minimum amount of change (the\\nminimum sum of money) that you **cannot**  create.\\n\\nThe given coins can have any positive integer value and\\naren\'t necessarily unique (i.e., you can havemultiple coins of the same value).\\n\\nFor example, if you\'re given `coins = [1, 2, 5]`, the minimum amount of change that you can\'t create is `4`.\\nIf you\'re given no coins, the minimum amount of change that you can\'t create is `1`.\\n\\n**sample input**: `coins  = [5, 7, 1, 1, 2, 3, 22]`\\n**sample output**: `20`\\n\\n\x3c!--truncate--\x3e\\n\\n## solution\\n\\nfirst of all, let\'s define our test data:\\n\\n```scala\\n\\nval testData = List(\\n    1 -> List(),\\n    1 -> List(2),\\n    2 -> List(1),\\n    1 -> List(87),\\n    3 -> List(1, 1),\\n    4 -> List(1, 2, 5),\\n    6 -> List(1, 1, 1, 1, 1),\\n    3 -> List(6, 4, 5, 1, 1, 8, 9),\\n    29 -> List(1, 2, 3, 4, 5, 6, 7),\\n    20 -> List(1, 1, 2, 3, 5, 7, 22),\\n    32 -> List(5, 6, 1, 1, 2, 3, 4, 9),\\n    55 -> List(1, 5, 1, 1, 1, 10, 15, 20, 100)\\n)\\n```\\n\\nour first approach is a brute-froce approach: iterating over collections and mutating state:\\n\\n```scala\\nimport scala.annotation.tailrec\\nimport scala.util.control.Breaks.*\\n\\ndef nonConstructibleChange1(coins: List[Int]): Int = {\\n\\n  /**\\n   * as you can see, `helper` functions is a tail-rec function that\\n   * will check all natural numbers, one by one, and incremeting by 1,\\n   * until it does not find it in the sum of a give permutation of\\n   * our coins.\\n   */\\n  @tailrec\\n  def helper(n: Int, coins: List[Int]): Int = {\\n    if coins.contains(n) then helper(n + 1, coins)\\n    else\\n      // doing `coins.permutations` is super brute-force\\n      // the longer the list, the most permutations to check\\n      LazyList.from(coins.permutations).find { list =>\\n        // using mutable state in order to track sum number\\n        // up to a given condition.\\n        var acc = 0\\n        breakable {\\n          for { i <- list } {\\n            acc = acc + i\\n            if acc >= n then break\\n          }\\n        }\\n        acc == n\\n      } match\\n        case Some(_) => helper(n + 1, coins)\\n        case None    => n\\n  }\\n\\n  coins match {\\n    // checking if we have inputs at all, if not, 1 is the min non-constructible change\\n    case Nil                     => 1\\n    // if input is not empty but the smallest coin is > than 1 then, again,\\n    // 1 is the min non-constructible change\\n    case h :: _ if coins.min > 1 => 1\\n    // if our input is not empty is has a 1 in it, we do the brute-force approach\\n    case _                       => helper(2, coins.sorted)\\n  }\\n}\\n```\\n\\nlet\'s give it try with out test data:\\n\\n```scala\\ntestData.map { case (expected, coins) =>\\n  expected == nonConstructibleChange1(coins)\\n}.forall(b => b) match\\n  case true => \\"yay! it\'s working!\\"\\n  case _    => \\"doh! let\'s debug :(\\"\\n// res0: String = \\"yay! it\'s working!\\"\\n```\\n\\nnoice! it is working OK. now, let\'s try to improve a bit removing mutation and `breakable` usage. how to do that? I thing that we need to `fold` while holding our condition.\\nso, for this `fold` while thing, I have no idea if there is something alike in standard\\nlibrary so, let\'s implement our own.\\n\\n```scala\\nimport $dep.`org.typelevel::cats-core:2.7.0`\\n\\nimport cats.kernel.Monoid\\nimport cats.implicits.*\\n\\ndef foldWhile[A](as: List[A], p: A => Boolean)(implicit A: Monoid[A]): A = {\\n\\n  def fold(acc: A, as: List[A]): A = {\\n    as match\\n      case Nil => acc\\n      case h :: t =>\\n        val aa = A.combine(acc, h)\\n        if p(aa) then fold(aa, t) else acc\\n  }\\n\\n  fold(A.empty, as)\\n}\\n\\nfoldWhile(List(5, 7, 1, 1, 2, 3, 22), _ <= 20) === 19\\n// res1: Boolean = true\\n```\\n\\nand now let\'s leverage our `foldWhile` :)\\n\\n```scala\\ndef nonConstructibleChange2(coins: List[Int]): Int = {\\n\\n  @tailrec\\n  def helper(n: Int, coins: List[Int]): Int = {\\n\\n    if coins.contains(n) then helper(n + 1, coins)\\n    else\\n      LazyList\\n        .from(coins.permutations)\\n        .find(l => foldWhile[Int](l, _ <= n) === n) match {\\n          case Some(_) => helper(n + 1, coins)\\n          case None    => n\\n        }\\n  }\\n\\n  coins match {\\n    case Nil                     => 1\\n    case h :: _ if coins.min > 1 => 1\\n    case _                       => helper(2, coins.sorted)\\n  }\\n}\\n\\ntestData.map { case (expected, coins) =>\\n  expected == nonConstructibleChange2(coins)\\n}.forall(b => b) match\\n  case true => \\"yay! it\'s working!\\"\\n  case _    => \\"doh! let\'s debug :(\\"\\n// res2: String = \\"yay! it\'s working!\\"\\n```\\n\\nnote that this solution is not optimal at all.\\nthere is a algorithmic solution that we will visit next time."},{"id":"roman-to-decimal","metadata":{"permalink":"/blog/roman-to-decimal","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-01-31-roman-to-decimal.md","source":"@site/blog/2022-01-31-roman-to-decimal.md","title":"roman number to decimal number","description":"description","date":"2022-01-31T00:00:00.000Z","formattedDate":"January 31, 2022","tags":[{"label":"scala","permalink":"/blog/tags/scala"},{"label":"algo","permalink":"/blog/tags/algo"}],"readingTime":3.455,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"roman-to-decimal","title":"roman number to decimal number","authors":["ravila"],"tags":["scala","algo"]},"prevItem":{"title":"non-constructible change","permalink":"/blog/non-constructible-change"},"nextItem":{"title":"is the number a palindrome?","permalink":"/blog/number-is-palindrome"}},"content":"## description\\n\\nroman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\\n\\n```\\nSymbol       Value\\nI             1\\nV             5\\nX             10\\nL             50\\nC             100\\nD             500\\nM             1000\\n```\\n\\nfor example, 2 is written as `II` in roman numeral, just two one\'s added together. 12 is written as `XII`, which is simply `X + II`. \\nthe number 27 is written as `XXVII`, which is `XX + V + II`.\\n\\nroman numerals are usually written largest to smallest from left to right. however, the numeral for four is not `IIII`. \\ninstead, the number four is written as `IV`. because the one is before the five we subtract it making four. \\nthe same principle applies to the number nine, which is written as `IX`. \\nthere are six instances where subtraction is used:\\n\\n- `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \\n- `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \\n- `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\\n\\ngiven a roman numeral, convert it to an integer.\\n\\n\x3c!--truncate--\x3e\\n\\n### constraints\\n\\n- `1 <= s.length <= 15`\\n- `s` contains only the characters (`I`, `V`, `X`, `L`, `C`, `D`, `M`).\\n- it is guaranteed that s is a valid roman numeral in the range [1, 3999].\\n\\n## solution\\n\\n\\nthis time we are going to try to solve the challenge in 3 different ways.\\nbut firts, let\'s define two support `Map`s:\\n\\n```scala\\nval symbolAndValue = Map(\\n    \'I\' -> 1,\\n    \'V\' -> 5,\\n    \'X\' -> 10,\\n    \'L\' -> 50,\\n    \'C\' -> 100,\\n    \'D\' -> 500,\\n    \'M\' -> 1000\\n  )\\n\\nval specialSymbols = Map(\\n  \\"IV\\" -> 4,\\n  \\"IX\\" -> 9,\\n  \\"XL\\" -> 40,\\n  \\"XC\\" -> 90,\\n  \\"CD\\" -> 400,\\n  \\"CM\\" -> 900\\n)\\n```\\n\\n### scala as a better java\\n\\nlet\'s implement a function using scala as a better java).\\nso, our function should:\\n\\n- mutate state\\n- and, iterate not recurs\\n\\n```scala\\ndef romanToIntJavaLike(s: String): Int = {\\n  var sum = 0\\n  val size = s.length\\n  var i = 0\\n  while (i < size) {\\n    val a = s(i)\\n\\n    // extracting next char\\n    val j = i + 1\\n    if (j < size) {\\n      val str = s\\"$a${s(j)}\\"\\n\\n      // and finding if the pair of current and next is s special case\\n      specialSymbols.get(str) match {\\n        case Some(n) =>\\n          sum = sum + n\\n          i = i + 2\\n        case None =>\\n          symbolAndValue.get(a).foreach { n =>\\n            sum = sum + n\\n            i = i + 1\\n          }\\n      }\\n    } else {\\n      symbolAndValue.get(a).foreach { n =>\\n        sum = sum + n\\n        i = i + 1\\n      }\\n    }\\n\\n  }\\n\\n  sum\\n}\\n```\\n\\nas you can see, `ronamToIntJavaLike`:\\n\\n- defines a accumulator `sum` \\n- iterate its input string `s` char-by-char\\n- crusial part is checking if there is a next char from our current char so we can check if the pair is a special case\\n\\nlet\'s give it a try:\\n\\n```scala\\nromanToIntJavaLike(\\"III\\")     // 3\\n// res0: Int = 3     // 3\\nromanToIntJavaLike(\\"LVIII\\")   // 58\\n// res1: Int = 58   // 58\\nromanToIntJavaLike(\\"MCMXCIV\\") // 1994\\n// res2: Int = 1994\\n```\\n\\nwelp, implementation seems to work.\\n\\n### scala-ish?\\n\\nthe scala-ish solution should:\\n\\n- be tail recursive\\n- leverage pattern matching\\n\\n```scala\\ndef romanToInt(s: String): Int = {\\n  val valueOfSymbol: Char => Int = symbolAndValue.getOrElse(_, 0)\\n\\n  @tailrec\\n  def go(chars: List[Char], sum: Int): Int = {\\n    chars match {\\n      case c1 :: c2 :: tail =>\\n        specialSymbols.get(s\\"$c1$c2\\") match {\\n          case Some(n) => go(tail, sum + n)\\n          // note that if c1 and c2 pair was not an specil sumbol i.e. IV\\n          // we only discard c1 and c2 is part of our collection for the next\\n          // recursive call\\n          case None    => go(c2 :: tail, valueOfSymbol(c1) + sum)\\n        }\\n      case c1 :: tail => go(tail, valueOfSymbol(c1) + sum)\\n      case Nil        => sum\\n    }\\n  }\\n\\n  go(s.toList, 0)\\n}\\n```\\n\\nlet\'s give it a try:\\n\\n```scala\\nromanToInt(\\"III\\")\\n// res3: Int = 3\\nromanToInt(\\"LVIII\\")\\n// res4: Int = 58\\nromanToInt(\\"MCMXCIV\\")\\n// res5: Int = 1994\\n```\\n\\nwelp, this implementation seem to work correctly too! yay!"},{"id":"number-is-palindrome","metadata":{"permalink":"/blog/number-is-palindrome","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-01-26-number-is-palindrome.md","source":"@site/blog/2022-01-26-number-is-palindrome.md","title":"is the number a palindrome?","description":"description","date":"2022-01-26T00:00:00.000Z","formattedDate":"January 26, 2022","tags":[{"label":"scala","permalink":"/blog/tags/scala"},{"label":"algo","permalink":"/blog/tags/algo"}],"readingTime":3.895,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"number-is-palindrome","title":"is the number a palindrome?","authors":["ravila"],"tags":["scala","algo"]},"prevItem":{"title":"roman number to decimal number","permalink":"/blog/roman-to-decimal"},"nextItem":{"title":"sum triangle from array","permalink":"/blog/sum-triangle-from-array"}},"content":"## description\\n\\nGiven an integer `x`, return `true` if `x` is palindrome integer.\\nAn integer is a palindrome when it reads the same backward as forward.\\nFor example, `121` is a palindrome while `123` is not.\\n\\n### constraints\\n\\n- `x >= 0`\\n- usage of strings is prohibited\\n\\n\x3c!--truncate--\x3e\\n\\n## solution\\n\\n\\nfirst idea is to decompose the given number in 3 parts:\\n\\n```\\nx = 123321\\nfirst  = 1\\nlast   = 1\\nothers = 2332\\n```\\n\\nwith the number decoposition it would be possible to decompose the number till either:\\n\\n1. `first != last`\\n2. or, it is not possible to decompose the number i.e. number of one digit `1`\\n\\nso, let\'s try to implement a function to decompose a nuber:\\n\\n```scala\\ndef isOneDigit(n: Int): Boolean = n >= 0 && n < 10\\n\\ndef deconstruct(number: Int): (Int, Option[Int], Int) = {\\n\\n  if (isOneDigit(number)) (number, None, number)\\n  else {\\n\\n    val n = {\\n      val a = Math.log10(number).intValue()\\n      Math.pow(10, a).intValue()\\n    }\\n\\n    val firstDigit = number / n\\n    val lastDigit = number % 10\\n    val left = {\\n      if (isOneDigit(number / 10)) None\\n      else Some((number % n) / 10)\\n    }\\n\\n    (firstDigit, left, lastDigit)\\n  }\\n}\\n```\\n\\nas you case `deconstruct` returns a three-tuple with an `Option` in the middle.\\nlet\'s see how `deconstruct` behaves:\\n\\n```scala\\ndeconstruct(123)\\n// res0: (Int, Option[Int], Int) = (1, Some(value = 2), 3)\\ndeconstruct(1)\\n// res1: (Int, Option[Int], Int) = (1, None, 1)\\ndeconstruct(11)\\n// res2: (Int, Option[Int], Int) = (1, None, 1)\\n```\\n\\nokay... it seems there are couple special cases here:\\n\\n1. when we pass a 1-digit number: `first` and `last` will be _that_ and `others` will be a `None` \\n2. and, when we pass a 2-digits number: `other` will be `None` too\\n\\nso, it seems we kind of have a base case for a recursive function that will find out\\nif a number is a palindrome or not:\\n\\n```scala\\ndef isPalindrome(number: Int): Boolean = {\\n  @tailrec\\n  def recur(number: Int, acc: Boolean): Boolean = {\\n    val (h, ns, t) = deconstruct(number)\\n    val bool       = h == t && acc\\n    if (bool) {\\n      ns match {\\n        case Some(value) => recur(value, bool)\\n        case None        => bool\\n      }\\n    } else false\\n  }\\n\\n  recur(number, true)\\n}\\n\\nisPalindrome(1203021)\\n// res3: Boolean = false\\nisPalindrome(123421)\\n// res4: Boolean = false\\nisPalindrome(123321)\\n// res5: Boolean = true\\nisPalindrome(10001)\\n// res6: Boolean = true\\nisPalindrome(1000)\\n// res7: Boolean = false\\nisPalindrome(8)\\n// res8: Boolean = true\\nisPalindrome(0)\\n// res9: Boolean = true\\n```\\n\\nwelp... obviously something is not working as expects \ud83d\ude13\\nour `deconstruct` functions seem to be the suspected here.\\nso let\'s _debug_ it:\\n\\n```scala\\ndeconstruct(1203021) == (1, Some(20302), 1)\\n// res10: Boolean = true\\ndeconstruct(20302)\\n// res11: (Int, Option[Int], Int) = (2, Some(value = 30), 2)\\n```\\n\\n\ud83e\udd21 `deconstruct` has no respect for the leading zeros which is OK because `30 = 030` and we are working with `Int`s\\n\\ntime to try different approach. what bout an accumulative approach?\\n\\n```scala\\ncase class Acc private (org: List[Int], reversed: List[Int]) { self =>\\n  def add(digit: Int): Acc = Acc(\\n    org      = self.org :+ digit,\\n    reversed = digit +: self.reversed\\n  )\\n}\\nobject Acc {\\n  def empty: Acc = Acc(List.empty, List.empty)\\n}\\n```\\n\\n`Acc` is our accumulative structure. it does maintian 2 lists \\nand every time we want to `add` a number to it:\\n\\n1. it will append the digit to one list `org`\\n2. and, it will preppend the same digit to the other list `reversed`\\n\\ntime to implement our function to check if a number is palindrome or not\\nusing `Acc`:\\n\\n```scala\\ndef lastDigit(n: Int): Int = n % 10\\n\\ndef isPalindromeAcc(x: Int): Boolean =\\n  if (isOneDigit(x)) true\\n  else {\\n\\n    @tailrec\\n    def go(acc: Acc, n: Int): Acc =\\n      if (n > 0) go(((acc.add _) compose (lastDigit _))(n), n / 10)\\n      else acc\\n\\n    val Acc(org, reversed) = go(Acc.empty, x)\\n    org sameElements reversed\\n  }\\n```\\n\\nthe function `isPalindromAcc`:\\n\\n- check if `x` is a number of one digit (short-circuit)\\n- \\"deconstruct\\" `x` from right to left and `add`-em to an `Acc`\\n- and last step, it compares the list from `Acc` using `sameElements`\\n  which checks that both list contains the same elements at the same order\\n\\nlet\'s give it a try:\\n\\n```scala\\nisPalindromeAcc(1203021)\\n// res12: Boolean = true\\nisPalindromeAcc(123421)\\n// res13: Boolean = false\\nisPalindromeAcc(10001)\\n// res14: Boolean = true\\nisPalindromeAcc(1000)\\n// res15: Boolean = false\\nisPalindromeAcc(8)\\n// res16: Boolean = true\\nisPalindromeAcc(0)\\n// res17: Boolean = true\\n```\\n\\nthis looks much better! \ud83e\udd73 things to note:\\n\\n- `isPalindrom` works perfectly for numbers without zeros in the middle and it is more efficient that `isPalindromAcc` in both time and space\\n- `isPalindromAcc` work great with any `x >= 0` but it is memory heavy"},{"id":"sum-triangle-from-array","metadata":{"permalink":"/blog/sum-triangle-from-array","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-01-19-sum-triagle-from-array.md","source":"@site/blog/2022-01-19-sum-triagle-from-array.md","title":"sum triangle from array","description":"another week, another code challenge","date":"2022-01-19T00:00:00.000Z","formattedDate":"January 19, 2022","tags":[{"label":"scala","permalink":"/blog/tags/scala"},{"label":"algo","permalink":"/blog/tags/algo"}],"readingTime":2.24,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"sum-triangle-from-array","title":"sum triangle from array","authors":["ravila"],"tags":["scala","algo"]},"prevItem":{"title":"is the number a palindrome?","permalink":"/blog/number-is-palindrome"},"nextItem":{"title":"add two number","permalink":"/blog/add-two-numbers"}},"content":"another week, another code challenge\\n\\n## description\\n\\ngiven an array of integers, print a sum triangle from it such that\\nthe first level has all array elements.\\nfrom then, at each level number of elements is one less than the previous level \\nand elements at the level is be the **sum** of consecutive two elements in the previous level. \\n\\n\x3c!--truncate--\x3e\\n\\n### example\\n\\n```scala\\ndef sumTriangle(number: List[Int]): List[List[Int]] = ???\\n\\nval input = List(1, 2, 3, 4, 5)\\n\\nshow(\\n  sumTriangle(input)\\n)\\n// stdout output\\n// List(\\n//   List(48),\\n//   List(20, 28), \\n//   List(8, 12, 16), \\n//   List(3, 5, 7, 9), \\n//   List(1, 2, 3, 4, 5)\\n// )\\n```\\n\\n## solution\\n\\n\\nfirst, we need to find a way to sum the elements of a list in pairs, \\nsomething that does like:\\n\\n```haskell\\n[1, 2, 3, 4, 5] -> [1 + 2, 2 + 3, 3 + 4, 4 + 5] = [3, 5, 7, 9]\\n```\\n\\n\ud83e\udd14 intresting enough, this looks like we need to `zip` one element with its successor.\\n\\n```scala\\ndef sum(ns: List[Int]): List[Int] =\\n  ns.zip(ns.tail).map { case (a, b) => a + b }\\n\\nsum(List(1, 2, 3, 4, 5))\\n// res0: List[Int] = List(3, 5, 7, 9)\\n```\\n\\nnice! this seems to work correctly. now that we can produce a level of\\nour trigle from a base level next step is to produce the whole triangle\\nfrom our input level (base level).\\n\\nbut first, let\'s get a bit piky and define a type alias for our triangle\\n\\n```scala\\ntype Triangle = List[List[Int]]\\n\\nobject Triangle {\\n  def apply(ns: List[Int]): Triangle = ns :: Nil\\n}\\n```\\n\\nnow we can implement our *main* function:\\n\\n```scala\\ndef sumTriangle(numbers: List[Int]): Triangle = {\\n\\n  @tailrec\\n  def go(ns: List[Int], triangle: Triangle): Triangle =\\n    ns match {\\n      case _ :: _ =>\\n        val level = sum(ns)\\n        go(level, level :: triangle)\\n      case Nil => triangle\\n    }\\n\\n  go(numbers, Triangle(numbers))\\n}\\n```\\n\\nas you may notice, this implementation is tail recursive (proved by the compiler)\\nand it builds a triangle from bottom to top.\\nlet\'s give it a try!\\n\\n```scala\\nval triangle = sumTriangle(\\n  List(1, 2, 3, 4, 5)\\n)\\n// triangle: Triangle = List(\\n//   List(),\\n//   List(48),\\n//   List(20, 28),\\n//   List(8, 12, 16),\\n//   List(3, 5, 7, 9),\\n//   List(1, 2, 3, 4, 5)\\n// )\\n```\\n\\nas an extra let\'s try to pretty print our triangle\\n\\n```scala\\ndef show(triangle: Triangle): String =\\n  triangle.foldRight(\\"\\") { case (ns, str) =>\\n    s\\"${ns.mkString(\\",\\")}\\" ++ System.lineSeparator() ++ str\\n  }\\n\\nshow(triangle)\\n// res1: String = \\"\\"\\"\\n// 48\\n// 20,28\\n// 8,12,16\\n// 3,5,7,9\\n// 1,2,3,4,5\\n// \\"\\"\\"\\n```\\n\\n> PS. worth to mention that this blog post is a markdown file processed with the awesome [mdoc](https://scalameta.org/mdoc/) \ud83e\udd13"},{"id":"add-two-numbers","metadata":{"permalink":"/blog/add-two-numbers","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-01-10-add-two-numbers.md","source":"@site/blog/2022-01-10-add-two-numbers.md","title":"add two number","description":"time to solve another coding challenge.","date":"2022-01-10T00:00:00.000Z","formattedDate":"January 10, 2022","tags":[{"label":"scala","permalink":"/blog/tags/scala"},{"label":"algo","permalink":"/blog/tags/algo"}],"readingTime":5.73,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"add-two-numbers","title":"add two number","authors":["ravila"],"tags":["scala","algo"]},"prevItem":{"title":"sum triangle from array","permalink":"/blog/sum-triangle-from-array"},"nextItem":{"title":"sorted squared array","permalink":"/blog/sorted-squared-array"}},"content":"time to solve another coding challenge.\\n\\n## description\\n\\nYou are given two non-empty linked lists representing two non-negative integers.\\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\\nAdd the two numbers and return the sum as a linked list.\\n\\nYou may assume the two numbers do not contain any leading zero,\\nexcept the number 0 itself.\\n\\n\x3c!--truncate--\x3e\\n\\n### example\\n\\n```haskell\\nl1 = [2, 4, 3] -- 342\\nl2 = [5, 6, 4] -- 465\\n\\naddTwoNumbers l1 l2 == [7, 0, 8] -- 807 == 342 + 465\\n```\\n\\n### constraints\\n\\n1. the number of nodes in each linked list is in the range `[1, 100]`\\n2. `0 <= ListNode.x <= 9`\\n3. it is guaranteed that the list represents a number that does not have leading zeros\\n\\n### linked list representations\\n\\n```scala\\n// yes. this is no idiomatic scala. but for now, bear with me please!\\n\\ncase class ListNode(_x: Int = 0, _next: ListNode = null) {\\n  var next: ListNode = _next\\n  var x: Int = _x\\n}\\n```\\n\\n## solution\\n\\n\\nfirst, we need to define a function signature:\\n\\n```scala\\ndef addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = ???\\n```\\n\\nthen, let\'s create input for our function.\\n\\n```scala\\nval n1 = new ListNode(2, new ListNode(4, new ListNode(3)))\\nval n2 = new ListNode(5, new ListNode(6, new ListNode(4)))\\n```\\n\\nwhat comes to my mind is a recursive solution so we do as follow\\n\\n```scala\\n(2 + 5) == 7\\n(4 + 6) == 0 // 10 - we need to presereve the most-left digit (0) only and carry the other one (1) to the next operation\\n(3 + 4) == 7 + 1 == 8\\n```\\n\\nfirst thing first. we need a way to work with a number `x` given that `x = number_of_list_1 + number_of_list_2` \\nand `x >= 10`\\n\\n```scala\\n// terrible name :(\\ndef helper(n: Int): (Int, Int) =\\n  if (n >= 10) (1, n % 10)\\n  else (0, n)\\n```\\n\\ntime to code our recursive helper functions\\n\\n```scala\\n/**\\n* @param as list 1\\n* @param bs list 2\\n* @param acc our seed/accumulator list\\n* @param r the digit to carry for the next operation\\n*          if the sum of two numbers is 10 then r = 1\\n*          for the next iteration \\n*/\\n@tailrec\\nfinal def loop(as: ListNode, bs: ListNode, acc: ListNode, r: Int): ListNode = {\\n  (as, bs) match {\\n    // base case, when both lists are \\"empty\\"\\n    // BUT we have an r to include as last digit (not leading zero)\\n    case (null, null) if r > 0 => new ListNode(r, acc)\\n\\n    // base case, when both lists are \\"empty\\" but without r\\n    case (null, null)          => acc\\n\\n    // following two cases are similar and handle\\n    // the scenario where one of the 2 lists have elements\\n    // but the other list is empty\\n    case (_, null) =>\\n      val (nr, a) = helper(as.x + r)\\n      loop(\\n        as.next,\\n        bs = null,\\n        acc = new ListNode(a, acc),\\n        nr\\n      )\\n    case (null, _) =>\\n      val (nr, b) = helper(bs.x + r)\\n      loop(\\n        as = null,\\n        bs.next,\\n        acc = new ListNode(b, acc),\\n        nr\\n      )\\n\\n    // when both lists have elements\\n    case (_, _) =>\\n      val a = as.x\\n      val b = bs.x\\n      val (nr, c) = helper(a + b + r)\\n      loop(\\n        as.next,\\n        bs.next,\\n        acc = new ListNode(c, acc),\\n        nr\\n      )\\n  }\\n}\\n```\\n\\nit\'s time to implement our \\"main\\" function\\n\\n```scala\\ndef addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {\\n  // this is safe given the constraints above\\n  val a = l1.x\\n  val b = l2.x\\n  val (r, c) = helper(a + b)\\n  loop(\\n    l1.next,\\n    l2.next,\\n    acc = new ListNode(c),\\n    r\\n  )\\n}\\n```\\n\\ntime to give it a try to our solution:\\n\\n```scala\\nval listNode = addTwoNumbers(n1, n2)\\n// listNode: ListNode = ListNode(\\n//   _x = 8,\\n//   _next = ListNode(_x = 0, _next = ListNode(_x = 7, _next = null))\\n// )\\n```\\n\\nhmm? maybe we can define a utility function to pretty print our list\\n\\n```scala\\n@tailrec\\nprivate def toList(ln: ListNode, acc: List[Int]): List[Int] =\\n  if (ln == null) acc\\n  else toList(ln.next, acc :+ ln.x)\\n\\ndef show(listNode: ListNode): String =\\n  toList(listNode, List.empty).mkString(\\" -> \\")\\n\\nshow(listNode)\\n// res0: String = \\"8 -> 0 -> 7\\"\\n```\\n\\nonce again *hmm?* our resulting list is not in good order, rigth?\\nwhy don\'t we reverse it?\\n\\n```scala\\ndef reverse(listNode: ListNode): ListNode = {\\n\\n  @tailrec\\n  def loop(ln: ListNode, acc: ListNode): ListNode =\\n    if (ln == null) acc\\n    else loop(ln.next, new ListNode(ln.x, acc))\\n\\n  loop(listNode.next, new ListNode(listNode.x))\\n}\\n\\nshow(\\n  reverse(listNode)\\n)\\n// res1: String = \\"7 -> 0 -> 8\\"\\n```\\n\\nnow that look better!\\n\\n```scala\\ndef addTwoNumbersImproved(l1: ListNode, l2: ListNode): ListNode = {\\n  // this is safe given the constraints above\\n  val a = l1.x\\n  val b = l2.x\\n  val (r, c) = helper(a + b)\\n  reverse(\\n    loop(\\n      l1.next,\\n      l2.next,\\n      acc = new ListNode(c),\\n      r\\n    )\\n  )\\n}\\n```\\n\\nbut... that was a pretty simplistic way to test our solution, don\'t you think?\\n\\nwe can do better with a great library:\\n[scalacheck](https://scalacheck.org/index.html)\\n\\nlet\'s start importing what we need from scalacheck\\n\\n```scala\\nimport org.scalacheck._\\nimport org.scalacheck.Prop._\\n```\\n\\nscalacheck work require us to define `Prop`s. our `Prop` will look\\nsomething like:\\n\\n```scala\\nval myProp = forAll { (input: (ListNode, ListNode, Int)) => ??? }\\n```\\n\\nnow it is time to define `Gen`s and `Arbitrary` required for our `Prop`\\nfirst, a `Gen[ListNode]`\\n\\n```scala\\n//generates pair like:\\n// (\\n//   10,\\n//   ListNode(0, ListNode(1))\\n// )\\nval listNodeGen: Gen[(Int, ListNode)] = for {\\n  size <- Gen.chooseNum(1, 8) // our lists will have up to 8 nodes\\n  head <- Gen.chooseNum(1, 9) // we do this hold constraint no. 3\\n  tail <- Gen.listOfN(size - 1, Gen.chooseNum(0, 9)) // trailing digits can be 0-9\\n  _list = head :: tail\\n  n = _list.mkString.toInt\\n  listNode = tail.reverse.foldRight(new ListNode(head)) { (i, ln) =>\\n    new ListNode(i, ln)\\n  }\\n} yield (n, listNode)\\n```\\n\\nnow we need to define an `Arbitrary` for out `(ListNode, ListNode, Int)` type\\n\\n```scala\\ntype Input = (ListNode, ListNode, Int)\\n\\n// generates tuples like:\\n// (\\n//   ListNode(1),\\n//   ListNode(0, ListNode(1)),\\n//   11\\n// )\\nval inputGen: Gen[Input] =\\n  for {\\n    (n1, l1) <- listNodeGen\\n    (n2, l2) <- listNodeGen\\n  } yield (l1, l2, n1 + n2)\\n\\nimplicit val arb: Arbitrary[Input] = Arbitrary(inputGen)\\n```\\n\\nwe have all we need to define our `Prop`\\n\\n```scala\\nval prop = forAll { (input: Input) =>\\n\\n  // unapplying our input to avoid `._1` syntax\\n  val (l1, l2, n) = input\\n\\n  // applying our solution\\n  val result = addTwoNumbersImproved(l1, l2)\\n\\n  // we need to do this in order to prove our solution\\n  val nn = {\\n    val reversed = reverse(result)\\n    // ListNode to immutable.List to Int\\n    toList(reversed, List.empty).mkString.toInt\\n  }\\n\\n  n == nn\\n}\\n// prop: Prop = Prop\\n\\nprop.check()\\n// + OK, passed 100 tests.\\n```\\n\\nnow with \\"random\\" inputs to our solution and 100 test\\nwe can be somehow sure that it works! yay!"},{"id":"sorted-squared-array","metadata":{"permalink":"/blog/sorted-squared-array","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-01-03-sorted-squared-array/index.mdx","source":"@site/blog/2022-01-03-sorted-squared-array/index.mdx","title":"sorted squared array","description":"this time we will try to (satisfactory) solve a coding challenge.","date":"2022-01-03T00:00:00.000Z","formattedDate":"January 3, 2022","tags":[{"label":"algo","permalink":"/blog/tags/algo"},{"label":"kotlin","permalink":"/blog/tags/kotlin"}],"readingTime":1.61,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"sorted-squared-array","title":"sorted squared array","authors":["ravila"],"tags":["algo","kotlin"]},"prevItem":{"title":"add two number","permalink":"/blog/add-two-numbers"},"nextItem":{"title":"haskell dollar-sign operator","permalink":"/blog/dollar-sign-operator"}},"content":"import CodeBlock from \'@theme/CodeBlock\';\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nimport FirstAttempt from \'!!raw-loader!./solutions/first-attempt.kts\';\\nimport SecondAttempt from \'!!raw-loader!./solutions/second-attempt.kts\';\\nimport BonusAttempt from \'!!raw-loader!./solutions/bonus-attempt.kts\';\\nimport BonusScalaSolution from \'!!raw-loader!./solutions/scala-bonus.worksheet.sc\';\\n\\nthis time we will try to (satisfactory) solve a coding challenge.\\n\\n### description\\n\\nwrite a function that takes in a non-empty array of integers that are sorted\\nin ascending order and returns a new array of the same length with the squares\\nof the original integers also sorted in ascending order.\\n\\n\x3c!--truncate--\x3e\\n\\n### first attempt\\n\\nfirst attempt (which fails when `array` includes negative numbers)\\ngiven `array = [-2, -1]` as input, output is `[4, 1]` which is wrong\\nbecause correct output should be sorted in ascending order:\\n\\n<CodeBlock className=\\"language-kotlin\\" title=\\"first-attempt.kts\\">{FirstAttempt}</CodeBlock>\\n\\nwhat i like from `first-attempt` (failed) solution is that\\n**we have no state** (we are not mutating anything), we are only\\ntraversing our input array once and generating a new array as our output.\\n\\n### second attempt\\n\\nan _optimal_ solution would be to use a data structure that preserves\\nthe order of its elements i.e binary tree; but, given that we have no b-tree at our disposal we can leverage\\nKotlin native [BinarySearch](https://kotlinlang.org/docs/list-operations.html#binary-search-in-sorted-lists)\\nmethods in `List`. we need to be careful with the return value of \\nsuch a function in order to prevent index bound exceptions:\\n\\n<CodeBlock className=\\"language-kotlin\\" title=\\"second-attempt.kts\\">{SecondAttempt}</CodeBlock>\\n\\nwhat i **dislike** from `second-attempt` solution is that: we have state mutations.\\non the other hand, i like that we are still traversing our input array once \\nmeaning `O(n)` complexity which I think is nice!\\n\\n### bonus\\n\\nas a bonus here is a 3rd optional solution that is not as efficient as the previous one\\nbut this third solution is based on immutable data structures which is always good:\\n\\n<Tabs>\\n  <TabItem value=\\"kotlin\\" label=\\"Kotlin\\" default>\\n    <CodeBlock className=\\"language-kotlin\\" title=\\"bonus-attempt.kts\\">{BonusAttempt}</CodeBlock>\\n  </TabItem>\\n  <TabItem value=\\"scala\\" label=\\"Scala\\">\\n    <CodeBlock className=\\"language-scala\\" title=\\"scala-bonus.worksheet.sc\\">{BonusScalaSolution}</CodeBlock>\\n  </TabItem>\\n</Tabs>\\n\\n> PD. in case you are wondering bout the `kscript` in the codeblocks take a look at:\\n> [holgerbrandl/kscript](https://github.com/holgerbrandl/kscript)"},{"id":"dollar-sign-operator","metadata":{"permalink":"/blog/dollar-sign-operator","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2021-12-27-dollar-sign-operator.md","source":"@site/blog/2021-12-27-dollar-sign-operator.md","title":"haskell dollar-sign operator","description":"The ($) operator is a convenience for when you want to express","date":"2021-12-27T00:00:00.000Z","formattedDate":"December 27, 2021","tags":[{"label":"haskell","permalink":"/blog/tags/haskell"}],"readingTime":0.745,"truncated":true,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"dollar-sign-operator","title":"haskell dollar-sign operator","authors":["ravila"],"tags":["haskell"]},"prevItem":{"title":"sorted squared array","permalink":"/blog/sorted-squared-array"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"The `($)` operator is a convenience for when you want to express\\nsomething with less pairs of parenths.\\n\\n\x3c!--truncate--\x3e\\n\\nType of `($)` is:\\n\\n``` haskell\\n($) :: (a -> b) -> a -> b -- Defined in \u2018GHC.Base\u2019\\ninfixr 0 $\\n```\\n\\nWhich means that:\\n\\n1.  it is a infix operator\\n2.  it associates to the right\\n3.  and, it has the lowest possibile precedence\\n\\nUsage example:\\n\\n```haskell\\n_ =(2^) (2 + 2) -- 16\\n```\\n\\nAbove code we need all the parenths because we want to first evaluate\\n`(2 + 2)`. If we remove the parenths the result is different:\\n\\n```haskell\\n_ = (2^) 2 + 2 -- 6\\n```\\n\\nHere is where `($)` comes handy:\\n\\n```haskell\\n_ = (2^) $ 2 + 2 -- 16\\n```\\n\\nThis happens because of how `($)` associates.\\nSo, first `(2 + 2)` is evaluted and its results is used in `(2^)`."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/Rafailong/blog/tree/main/docs/blog/2021-12-25-welcome.md","source":"@site/blog/2021-12-25-welcome.md","title":"Welcome","description":"Hi there and welcome to my blog!","date":"2021-12-25T00:00:00.000Z","formattedDate":"December 25, 2021","tags":[],"readingTime":0.19,"truncated":false,"authors":[{"name":"Rafael Avila","url":"https://github.com/Rafailong","imageURL":"https://github.com/Rafailong.png","key":"ravila"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["ravila"]},"prevItem":{"title":"haskell dollar-sign operator","permalink":"/blog/dollar-sign-operator"}},"content":"Hi there and welcome to my blog!\\n\\nAt a glance you will find content about things I like,\\nthings I dislike, and things I might be learning/interested on.\\n\\nSo, that is all for now. Have a good one!"}]}')}}]);