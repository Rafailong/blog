"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7960],{3905:function(n,e,t){t.d(e,{Zo:function(){return u},kt:function(){return h}});var a=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,a,i=function(n,e){if(null==n)return{};var t,a,i={},o=Object.keys(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var s=a.createContext({}),c=function(n){var e=a.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},u=function(n){var e=c(n.components);return a.createElement(s.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,o=n.originalType,s=n.parentName,u=l(n,["components","mdxType","originalType","parentName"]),m=c(t),h=i,g=m["".concat(s,".").concat(h)]||m[h]||p[h]||o;return t?a.createElement(g,r(r({ref:e},u),{},{components:t})):a.createElement(g,r({ref:e},u))}));function h(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=n,l.mdxType="string"==typeof n?n:i,r[1]=l;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6973:function(n,e,t){t.r(e),t.d(e,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],l={slug:"non-constructible-change",title:"non-constructible change",authors:["ravila"],tags:["scala","algo"]},s=void 0,c={permalink:"/blog/non-constructible-change",editUrl:"https://github.com/Rafailong/blog/tree/main/docs/blog/2022-04-22-non-constructible-change.md",source:"@site/blog/2022-04-22-non-constructible-change.md",title:"non-constructible change",description:"description",date:"2022-04-22T00:00:00.000Z",formattedDate:"April 22, 2022",tags:[{label:"scala",permalink:"/blog/tags/scala"},{label:"algo",permalink:"/blog/tags/algo"}],readingTime:3.765,truncated:!0,authors:[{name:"Rafael Avila",url:"https://github.com/Rafailong",imageURL:"https://github.com/Rafailong.png",key:"ravila"}],frontMatter:{slug:"non-constructible-change",title:"non-constructible change",authors:["ravila"],tags:["scala","algo"]},prevItem:{title:"find available languages",permalink:"/blog/available-languages"},nextItem:{title:"roman number to decimal number",permalink:"/blog/roman-to-decimal"}},u={authorsImageUrls:[void 0]},p=[{value:"description",id:"description",level:2},{value:"solution",id:"solution",level:2}],m={toc:p};function h(n){var e=n.components,t=(0,i.Z)(n,r);return(0,o.kt)("wrapper",(0,a.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"description"},"description"),(0,o.kt)("p",null,"Given an array of positive integers representing the values of coins in your\npossession, write a function that returns the minimum amount of change (the\nminimum sum of money) that you ",(0,o.kt)("strong",{parentName:"p"},"cannot"),"  create."),(0,o.kt)("p",null,"The given coins can have any positive integer value and\naren't necessarily unique (i.e., you can havemultiple coins of the same value)."),(0,o.kt)("p",null,"For example, if you're given ",(0,o.kt)("inlineCode",{parentName:"p"},"coins = [1, 2, 5]"),", the minimum amount of change that you can't create is ",(0,o.kt)("inlineCode",{parentName:"p"},"4"),".\nIf you're given no coins, the minimum amount of change that you can't create is ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"sample input"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"coins  = [5, 7, 1, 1, 2, 3, 22]"),"\n",(0,o.kt)("strong",{parentName:"p"},"sample output"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"20")),(0,o.kt)("h2",{id:"solution"},"solution"),(0,o.kt)("p",null,"first of all, let's define our test data:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"\nval testData = List(\n    1 -> List(),\n    1 -> List(2),\n    2 -> List(1),\n    1 -> List(87),\n    3 -> List(1, 1),\n    4 -> List(1, 2, 5),\n    6 -> List(1, 1, 1, 1, 1),\n    3 -> List(6, 4, 5, 1, 1, 8, 9),\n    29 -> List(1, 2, 3, 4, 5, 6, 7),\n    20 -> List(1, 1, 2, 3, 5, 7, 22),\n    32 -> List(5, 6, 1, 1, 2, 3, 4, 9),\n    55 -> List(1, 5, 1, 1, 1, 10, 15, 20, 100)\n)\n")),(0,o.kt)("p",null,"our first approach is a brute-froce approach: iterating over collections and mutating state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.annotation.tailrec\nimport scala.util.control.Breaks.*\n\ndef nonConstructibleChange1(coins: List[Int]): Int = {\n\n  /**\n   * as you can see, `helper` functions is a tail-rec function that\n   * will check all natural numbers, one by one, and incremeting by 1,\n   * until it does not find it in the sum of a give permutation of\n   * our coins.\n   */\n  @tailrec\n  def helper(n: Int, coins: List[Int]): Int = {\n    if coins.contains(n) then helper(n + 1, coins)\n    else\n      // doing `coins.permutations` is super brute-force\n      // the longer the list, the most permutations to check\n      LazyList.from(coins.permutations).find { list =>\n        // using mutable state in order to track sum number\n        // up to a given condition.\n        var acc = 0\n        breakable {\n          for { i <- list } {\n            acc = acc + i\n            if acc >= n then break\n          }\n        }\n        acc == n\n      } match\n        case Some(_) => helper(n + 1, coins)\n        case None    => n\n  }\n\n  coins match {\n    // checking if we have inputs at all, if not, 1 is the min non-constructible change\n    case Nil                     => 1\n    // if input is not empty but the smallest coin is > than 1 then, again,\n    // 1 is the min non-constructible change\n    case h :: _ if coins.min > 1 => 1\n    // if our input is not empty is has a 1 in it, we do the brute-force approach\n    case _                       => helper(2, coins.sorted)\n  }\n}\n")),(0,o.kt)("p",null,"let's give it try with out test data:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'testData.map { case (expected, coins) =>\n  expected == nonConstructibleChange1(coins)\n}.forall(b => b) match\n  case true => "yay! it\'s working!"\n  case _    => "doh! let\'s debug :("\n// res0: String = "yay! it\'s working!"\n')),(0,o.kt)("p",null,"noice! it is working OK. now, let's try to improve a bit removing mutation and ",(0,o.kt)("inlineCode",{parentName:"p"},"breakable")," usage. how to do that? I thing that we need to ",(0,o.kt)("inlineCode",{parentName:"p"},"fold")," while holding our condition.\nso, for this ",(0,o.kt)("inlineCode",{parentName:"p"},"fold")," while thing, I have no idea if there is something alike in standard\nlibrary so, let's implement our own."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import $dep.`org.typelevel::cats-core:2.7.0`\n\nimport cats.kernel.Monoid\nimport cats.implicits.*\n\ndef foldWhile[A](as: List[A], p: A => Boolean)(implicit A: Monoid[A]): A = {\n\n  def fold(acc: A, as: List[A]): A = {\n    as match\n      case Nil => acc\n      case h :: t =>\n        val aa = A.combine(acc, h)\n        if p(aa) then fold(aa, t) else acc\n  }\n\n  fold(A.empty, as)\n}\n\nfoldWhile(List(5, 7, 1, 1, 2, 3, 22), _ <= 20) === 19\n// res1: Boolean = true\n")),(0,o.kt)("p",null,"and now let's leverage our ",(0,o.kt)("inlineCode",{parentName:"p"},"foldWhile")," :)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def nonConstructibleChange2(coins: List[Int]): Int = {\n\n  @tailrec\n  def helper(n: Int, coins: List[Int]): Int = {\n\n    if coins.contains(n) then helper(n + 1, coins)\n    else\n      LazyList\n        .from(coins.permutations)\n        .find(l => foldWhile[Int](l, _ <= n) === n) match {\n          case Some(_) => helper(n + 1, coins)\n          case None    => n\n        }\n  }\n\n  coins match {\n    case Nil                     => 1\n    case h :: _ if coins.min > 1 => 1\n    case _                       => helper(2, coins.sorted)\n  }\n}\n\ntestData.map { case (expected, coins) =>\n  expected == nonConstructibleChange2(coins)\n}.forall(b => b) match\n  case true => "yay! it\'s working!"\n  case _    => "doh! let\'s debug :("\n// res2: String = "yay! it\'s working!"\n')),(0,o.kt)("p",null,"note that this solution is not optimal at all.\nthere is a algorithmic solution that we will visit next time."))}h.isMDXComponent=!0}}]);